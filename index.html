<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive Flowchart Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a better look and feel */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        /* Custom scrollbar styles for dark mode */
        .dark ::-webkit-scrollbar-thumb {
            background: #4a5568;
        }

        .dark ::-webkit-scrollbar-track {
            background: #2d3748;
        }

        canvas {
            cursor: default;
            touch-action: none;
        }

        .shape-palette-item {
            cursor: grab;
            transition: all 0.2s ease-in-out;
        }

            .shape-palette-item:active {
                cursor: grabbing;
                transform: scale(1.1);
            }
    </style>
    <link rel="preconnect" href="https://rsms.me/">
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex h-screen w-screen overflow-hidden">

    <!-- Left Sidebar: Shape Palette -->
    <aside id="shapes-palette" class="w-48 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 p-4 flex flex-col space-y-4 fixed md:relative h-full z-20 transition-transform -translate-x-full md:translate-x-0 overflow-y-auto">
        <h2 class="font-bold text-lg">Shapes</h2>
        <div class="space-y-3">
            <div id="shape-rectangle" class="shape-palette-item flex items-center space-x-2 p-2 rounded-lg border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 hover:shadow-md">
                <svg width="24" height="24" viewBox="0 0 24 16"><rect x="0" y="0" width="24" height="16" rx="2" stroke="currentColor" fill="none" stroke-width="2"></rect></svg>
                <span>Process</span>
            </div>
            <div id="shape-diamond" class="shape-palette-item flex items-center space-x-2 p-2 rounded-lg border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 hover:shadow-md">
                <svg width="24" height="24" viewBox="0 0 24 24"><path d="M12 2 L22 12 L12 22 L2 12 Z" stroke="currentColor" fill="none" stroke-width="2"></path></svg>
                <span>Decision</span>
            </div>
            <div id="shape-ellipse" class="shape-palette-item flex items-center space-x-2 p-2 rounded-lg border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 hover:shadow-md">
                <svg width="24" height="24" viewBox="0 0 24 16"><ellipse cx="12" cy="8" rx="11" ry="7" stroke="currentColor" fill="none" stroke-width="2"></ellipse></svg>
                <span>Start/End</span>
            </div>
            <div id="shape-pie" class="shape-palette-item flex items-center space-x-2 p-2 rounded-lg border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 hover:shadow-md">
                <svg width="24" height="24" viewBox="0 0 24 24"><path d="M12 2 A10 10 0 0 1 22 12 L12 12 Z" stroke="currentColor" fill="none" stroke-width="2"></path></svg>
                <span>Pie</span>
            </div>
            <div id="shape-checkmark" class="shape-palette-item flex items-center space-x-2 p-2 rounded-lg border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 hover:shadow-md">
                <svg width="24" height="24" viewBox="0 0 24 24"><path d="M5 13 l5 5 l10 -10" stroke="currentColor" fill="none" stroke-width="3" stroke-linecap="round"></path></svg>
                <span>Check</span>
            </div>
            <div id="shape-text" class="shape-palette-item flex items-center space-x-2 p-2 rounded-lg border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 hover:shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>
                <span>Text</span>
            </div>
            <div id="shape-image" class="shape-palette-item flex items-center space-x-2 p-2 rounded-lg border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700 hover:shadow-md">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                <span>Image</span>
            </div>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col">
        <!-- Top Toolbar -->
        <header class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-2 flex items-center justify-between">
            <div class="flex items-center space-x-1 md:space-x-3">
                <button id="shapes-toggle-btn" title="Toggle Shapes" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 md:hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
                </button>
                <button id="group-btn" title="Group Selected" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line></svg>
                </button>
                <button id="ungroup-btn" title="Ungroup Selected" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect></svg>
                </button>
            </div>
            <div class="hidden md:flex items-center space-x-3">
                <label for="import-file" class="cursor-pointer p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700" title="Import JSON">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                </label>
                <input type="file" id="import-file" class="hidden" accept=".json">

                <button id="export-json-btn" title="Export JSON" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="17 1, 21 5, 17 9"></polyline><path d="M3 11.999V5c0-1.105 0.895-2 2-2h11"></path><polyline points="7 23, 3 19, 7 15"></polyline><path d="M21 12.001v-0.001c0, 1.105-0.895, 2-2, 2H8"></path></svg>
                </button>
                <button id="export-png-btn" title="Export PNG" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                </button>
            </div>
            <div class="flex items-center space-x-1 md:space-x-3">
                <div class="hidden md:flex items-center space-x-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v18H3zM8 8v8h8"></path></svg>
                    <label for="snap-grid" class="text-sm font-medium">Snap to Grid</label>
                    <input type="checkbox" id="snap-grid" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                </div>
                <button id="theme-toggle-btn" title="Toggle Theme" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700">
                    <svg id="theme-icon-sun" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                    <svg id="theme-icon-moon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="block"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                </button>
                <button id="properties-toggle-btn" title="Toggle Properties" class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 md:hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3v18M18 9l-6 6-6-6" /></svg>
                </button>
            </div>
        </header>

        <!-- Canvas Area -->
        <div class="flex-1 bg-gray-800 relative">
            <canvas id="flowchart-canvas"></canvas>
            <!-- Hidden text area for live text editing -->
            <textarea id="text-editor" class="hidden absolute p-0 m-0 border border-blue-500 bg-white dark:bg-gray-700 dark:text-white" style="resize: none; overflow: hidden; white-space: pre;"></textarea>
        </div>
    </main>

    <!-- Right Sidebar: Properties Panel -->
    <aside id="properties-panel" class="w-64 bg-white dark:bg-gray-800 border-l border-gray-200 dark:border-gray-700 p-4 transition-transform transform translate-x-full fixed right-0 top-0 h-full z-20 md:relative md:translate-x-0">
        <h2 class="font-bold text-lg mb-4">Properties</h2>
        <div id="properties-content" class="space-y-4">
            <p class="text-gray-600 dark:text-gray-400">Select an object to see its properties.</p>
        </div>
    </aside>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('flowchart-canvas');
            const ctx = canvas.getContext('2d');
            const propertiesPanel = document.getElementById('properties-panel');
            const shapesPalette = document.getElementById('shapes-palette');
            const propertiesContent = document.getElementById('properties-content');
            const textEditor = document.getElementById('text-editor');

            let shapes = [];
            let connectors = [];
            let selectedItems = [];
            let selectedConnectors = [];
            let hoveredConnector = null;
            let draggedWaypointInfo = null;
            let isReconnecting = null;

            let isDragging = false;
            let isResizing = false;
            let isConnecting = false;
            let isPanning = false;
            let isSelecting = false;
            let isRotating = false;

            let lastMousePos = { x: 0, y: 0 };
            let startMousePos = { x: 0, y: 0 }; // Start pos for drag operations
            let startShapeState = null; // Store initial state for resizing
            let resizeHandle = null;
            let resizeAspectRatio = 1;
            let currentConnector = null;
            let panStart = { x: 0, y: 0 };
            let selectionBox = { x: 0, y: 0, width: 0, height: 0 };

            let cameraOffset = { x: 0, y: 0 };
            let cameraZoom = 1;
            const MAX_ZOOM = 5;
            const MIN_ZOOM = 0.1;
            const SCROLL_SENSITIVITY = 0.0005;
            const GRID_SIZE = 20;
            let snapToGrid = false;

            let theme = 'dark';

            let lastTap = 0;
            let lastTouchDistance = null;
            let isMultiTouching = false;


            // --- INITIALIZATION ---
            function init() {
                resizeCanvas();
                setupEventListeners();
                draw();
            }

            function resizeCanvas() {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
                draw();
            }

            // --- DRAWING ---
            function draw() {
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.translate(cameraOffset.x, cameraOffset.y);
                ctx.scale(cameraZoom, cameraZoom);

                drawGrid();

                connectors.forEach(c => drawConnector(c));
                shapes.forEach(s => drawShape(s));

                if (isSelecting) {
                    ctx.strokeStyle = 'rgba(52, 152, 219, 0.8)';
                    ctx.fillStyle = 'rgba(52, 152, 219, 0.1)';
                    ctx.lineWidth = 1 / cameraZoom;
                    ctx.strokeRect(selectionBox.x, selectionBox.y, selectionBox.width, selectionBox.height);
                    ctx.fillRect(selectionBox.x, selectionBox.y, selectionBox.width, selectionBox.height);
                }

                ctx.restore();
            }

            function drawGrid() {
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = 1 / cameraZoom;

                const viewLeft = -cameraOffset.x / cameraZoom;
                const viewTop = -cameraOffset.y / cameraZoom;
                const viewRight = (canvas.width - cameraOffset.x) / cameraZoom;
                const viewBottom = (canvas.height - cameraOffset.y) / cameraZoom;

                const startX = Math.floor(viewLeft / GRID_SIZE) * GRID_SIZE;
                const startY = Math.floor(viewTop / GRID_SIZE) * GRID_SIZE;

                for (let x = startX; x < viewRight; x += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, viewTop);
                    ctx.lineTo(x, viewBottom);
                    ctx.stroke();
                }
                for (let y = startY; y < viewBottom; y += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(viewLeft, y);
                    ctx.lineTo(viewRight, y);
                    ctx.stroke();
                }
            }

            function drawShape(shape) {
                const centerX = shape.x + shape.width / 2;
                const centerY = shape.y + shape.height / 2;

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(shape.rotation || 0);
                ctx.translate(-centerX, -centerY);

                ctx.globalAlpha = shape.opacity || 1;

                if (shape.type !== 'image') {
                    ctx.strokeStyle = shape.borderColor;
                    ctx.fillStyle = shape.fillColor;
                    ctx.lineWidth = shape.borderWidth / cameraZoom;
                }

                if (selectedItems.includes(shape)) {
                    ctx.shadowColor = 'rgba(0, 123, 255, 0.7)';
                    ctx.shadowBlur = 10 / cameraZoom;
                }

                switch (shape.type) {
                    case 'rectangle':
                        ctx.beginPath();
                        const r = Math.max(0, Math.min(shape.borderRadius || 0, shape.width / 2, shape.height / 2));
                        const x = shape.x, y = shape.y, w = shape.width, h = shape.height;
                        ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r); ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
                        break;
                    case 'diamond':
                        ctx.beginPath(); ctx.moveTo(shape.x + shape.width / 2, shape.y); ctx.lineTo(shape.x + shape.width, shape.y + shape.height / 2); ctx.lineTo(shape.x + shape.width / 2, shape.y + shape.height); ctx.lineTo(shape.x, shape.y + shape.height / 2); ctx.closePath();
                        break;
                    case 'ellipse':
                        ctx.beginPath(); ctx.ellipse(shape.x + shape.width / 2, shape.y + shape.height / 2, shape.width / 2, shape.height / 2, 0, 0, 2 * Math.PI);
                        break;
                    case 'pie':
                        ctx.beginPath(); ctx.moveTo(shape.x + shape.width / 2, shape.y + shape.height / 2); ctx.arc(shape.x + shape.width / 2, shape.y + shape.height / 2, Math.min(shape.width, shape.height) / 2, -Math.PI / 2, -Math.PI / 2 + (shape.angle * Math.PI / 180), false); ctx.closePath();
                        break;
                    case 'text':
                        ctx.beginPath(); ctx.rect(shape.x, shape.y, shape.width, shape.height);
                        break;
                    case 'image':
                        ctx.beginPath();
                        ctx.rect(shape.x, shape.y, shape.width, shape.height);
                        if (shape.imageSrc) {
                            if (!shape.imageElem) {
                                const img = new Image();
                                img.onload = () => { shape.imageElem = img; draw(); };
                                img.src = shape.imageSrc;
                                shape.imageElem = 'loading';
                            } else if (shape.imageElem !== 'loading') {
                                const img = shape.imageElem;
                                const fit = shape.imageFit || 'fill';
                                const sw = shape.width;
                                const sh = shape.height;
                                const iw = img.naturalWidth || img.width;
                                const ih = img.naturalHeight || img.height;
                                ctx.save(); ctx.clip();
                                if (fit === 'fill') { ctx.drawImage(img, shape.x, shape.y, sw, sh); }
                                else if (fit === 'aspectFit') {
                                    const scale = Math.min(sw / iw, sh / ih);
                                    const nw = iw * scale; const nh = ih * scale;
                                    ctx.drawImage(img, shape.x + (sw - nw) / 2, shape.y + (sh - nh) / 2, nw, nh);
                                } else if (fit === 'aspectFill') {
                                    const scale = Math.max(sw / iw, sh / ih);
                                    const nw = iw * scale; const nh = ih * scale;
                                    ctx.drawImage(img, shape.x + (sw - nw) / 2, shape.y + (sh - nh) / 2, nw, nh);
                                } else if (fit === 'center') {
                                    ctx.drawImage(img, shape.x + (sw - iw) / 2, shape.y + (sh - ih) / 2, iw, ih);
                                }
                                ctx.restore();
                            }
                        } else {
                            ctx.fillStyle = document.documentElement.classList.contains('dark') ? '#4a5568' : '#e2e8f0';
                            ctx.fill();
                            ctx.strokeStyle = '#cbd5e0';
                            ctx.lineWidth = 2 / cameraZoom;
                            ctx.setLineDash([5 / cameraZoom, 5 / cameraZoom]);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            ctx.fillStyle = '#718096';
                            ctx.font = `${14 / cameraZoom}px Inter`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('No Image', shape.x + shape.width / 2, shape.y + shape.height / 2);
                        }
                        break;
                    case 'checkmark':
                        ctx.strokeStyle = shape.borderColor; ctx.lineWidth = Math.min(shape.width, shape.height) * 0.15; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(shape.x + shape.width * 0.2, shape.y + shape.height * 0.5); ctx.lineTo(shape.x + shape.width * 0.45, shape.y + shape.height * 0.75); ctx.lineTo(shape.x + shape.width * 0.8, shape.y + shape.height * 0.25); ctx.stroke(); ctx.restore(); return;
                    case 'group':
                        ctx.setLineDash([5 / cameraZoom, 5 / cameraZoom]); ctx.beginPath(); ctx.rect(shape.x, shape.y, shape.width, shape.height);
                        break;
                }

                if (shape.type !== 'image') {
                    if (shape.fill) ctx.fill();
                    if (shape.border || (shape.type === 'text' && selectedItems.includes(shape))) ctx.stroke();
                } else if (shape.type === 'image' && selectedItems.includes(shape)) {
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 1 / cameraZoom;
                    ctx.stroke();
                }
                ctx.setLineDash([]);

                if (shape.type !== 'image') {
                    ctx.fillStyle = shape.textColor;
                    ctx.font = `${shape.fontSize}px Inter`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    wrapText(ctx, shape.text, shape.x + shape.width / 2, shape.y + shape.height / 2, shape.width - 10, shape.fontSize * 1.2);
                }

                if (selectedItems.length === 1 && selectedItems[0] === shape) {
                    drawHandles(shape);
                }

                ctx.restore();
            }

            function drawConnector(connector) {
                const isSelected = selectedConnectors.includes(connector);
                const isHovered = hoveredConnector === connector;

                let pathPoints = getConnectorPath(connector);
                if (pathPoints.length < 2) return;

                if (isReconnecting && isReconnecting.connector.id === connector.id) {
                    const tempPath = [...pathPoints];
                    if (isReconnecting.end === 'from') {
                        tempPath[0] = lastMousePos;
                    } else { // 'to'
                        tempPath[tempPath.length - 1] = lastMousePos;
                    }
                    pathPoints = tempPath;
                }

                const color = connector.color || '#ddd';
                const thickness = connector.thickness || 2;
                const lineStyle = connector.lineStyle || 'solid';
                const lineType = connector.lineType || 'line';
                const hasWaypoints = connector.waypoints && connector.waypoints.length > 0;

                ctx.strokeStyle = isSelected ? '#dc3545' : color;
                ctx.lineWidth = (thickness + (isSelected || isHovered ? 2 : 0)) / cameraZoom;

                if (lineStyle === 'dashed') {
                    ctx.setLineDash([8 / cameraZoom, 4 / cameraZoom]);
                } else if (lineStyle === 'dotted') {
                    ctx.setLineDash([thickness / cameraZoom, (thickness * 1.5) / cameraZoom]);
                }

                ctx.beginPath();
                if (lineType === 'curve' && hasWaypoints) {
                    ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                    let i = 1;
                    for (; i < pathPoints.length - 2; i++) {
                        const xc = (pathPoints[i].x + pathPoints[i + 1].x) / 2;
                        const yc = (pathPoints[i].y + pathPoints[i + 1].y) / 2;
                        ctx.quadraticCurveTo(pathPoints[i].x, pathPoints[i].y, xc, yc);
                    }
                    ctx.quadraticCurveTo(pathPoints[i].x, pathPoints[i].y, pathPoints[i + 1].x, pathPoints[i + 1].y);
                } else { // 'line'
                    ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                    for (let i = 1; i < pathPoints.length; i++) {
                        ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);

                if (pathPoints.length >= 2) {
                    let fromPointForArrow = pathPoints[pathPoints.length - 2];
                    drawArrowhead(ctx, fromPointForArrow, pathPoints[pathPoints.length - 1], isSelected, color);
                }

                if (isSelected) {
                    ctx.fillStyle = '#ffc107';
                    const handleSize = 6 / cameraZoom;
                    (connector.waypoints || []).forEach(wp => {
                        ctx.beginPath();
                        ctx.rect(wp.x - handleSize / 2, wp.y - handleSize / 2, handleSize, handleSize);
                        ctx.fill();
                    });
                }
            }

            function drawArrowhead(ctx, from, to, isSelected, color) {
                const headlen = 10 / cameraZoom;
                const angle = Math.atan2(to.y - from.y, to.x - from.x);
                ctx.strokeStyle = isSelected ? '#dc3545' : color;
                ctx.beginPath();
                ctx.moveTo(to.x, to.y);
                ctx.lineTo(to.x - headlen * Math.cos(angle - Math.PI / 6), to.y - headlen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(to.x, to.y);
                ctx.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 6), to.y - headlen * Math.sin(angle + Math.PI / 6));
                ctx.stroke();
            }

            function drawHandles(shape) {
                const handles = getResizeHandles(shape);
                const connectionPoints = getConnectionPoints(shape);
                const rotationHandle = getRotationHandle(shape);

                const handleSize = 8 / cameraZoom;
                const connectionPointSize = 5 / cameraZoom;

                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 1 / cameraZoom;
                ctx.beginPath();
                ctx.moveTo(shape.x + shape.width / 2, shape.y);
                ctx.lineTo(rotationHandle.x, rotationHandle.y);
                ctx.stroke();

                ctx.fillStyle = '#007bff';
                ctx.beginPath();
                ctx.arc(rotationHandle.x, rotationHandle.y, handleSize / 2, 0, Math.PI * 2);
                ctx.fill();

                for (const handle in handles) {
                    const pos = handles[handle];
                    ctx.fillRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
                }

                ctx.fillStyle = '#28a745';
                for (const point in connectionPoints) {
                    const pos = connectionPoints[point];
                    ctx.beginPath(); ctx.arc(pos.x, pos.y, connectionPointSize, 0, 2 * Math.PI); ctx.fill();
                }
            }

            function wrapText(context, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = ''; let lines = [];
                for (let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    let metrics = context.measureText(testLine);
                    let testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) { lines.push(line); line = words[n] + ' '; } else { line = testLine; }
                }
                lines.push(line);
                const totalHeight = lines.length * lineHeight;
                const startY = y - totalHeight / 2 + lineHeight / 2;
                for (let i = 0; i < lines.length; i++) { context.fillText(lines[i].trim(), x, startY + i * lineHeight); }
            }

            // --- EVENT LISTENERS ---
            function setupEventListeners() {
                window.addEventListener('resize', resizeCanvas);
                canvas.addEventListener('mousedown', onMouseDown);
                canvas.addEventListener('mousemove', onMouseMove);
                canvas.addEventListener('mouseup', onMouseUp);
                canvas.addEventListener('dblclick', onDoubleClick);
                canvas.addEventListener('wheel', onWheel);

                canvas.addEventListener('touchstart', onTouchStart);
                canvas.addEventListener('touchmove', onTouchMove);
                canvas.addEventListener('touchend', onTouchEnd);

                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);

                document.querySelectorAll('.shape-palette-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        const type = e.target.closest('.shape-palette-item').id.split('-')[1];
                        e.dataTransfer.setData('text/plain', type);
                    });
                    item.addEventListener('click', (e) => {
                        const type = e.currentTarget.id.split('-')[1];
                        const x = (-cameraOffset.x + canvas.width / 2) / cameraZoom;
                        const y = (-cameraOffset.y + canvas.height / 2) / cameraZoom;
                        addShape(type, x, y);
                        draw();
                    });
                });
                canvas.addEventListener('dragover', (e) => e.preventDefault());
                canvas.addEventListener('drop', onDrop);

                document.getElementById('snap-grid').addEventListener('change', (e) => { snapToGrid = e.target.checked; draw(); });
                document.getElementById('export-json-btn').addEventListener('click', exportJSON);
                document.getElementById('export-png-btn').addEventListener('click', exportPNG);
                document.getElementById('import-file').addEventListener('change', importJSON);
                document.getElementById('group-btn').addEventListener('click', groupSelection);
                document.getElementById('ungroup-btn').addEventListener('click', ungroupSelection);
                document.getElementById('shapes-toggle-btn').addEventListener('click', () => shapesPalette.classList.toggle('-translate-x-full'));
                document.getElementById('properties-toggle-btn').addEventListener('click', () => propertiesPanel.classList.toggle('translate-x-full'));

                document.getElementById('theme-toggle-btn').addEventListener('click', () => {
                    document.documentElement.classList.toggle('dark');
                    theme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
                    const sunIcon = document.getElementById('theme-icon-sun');
                    const moonIcon = document.getElementById('theme-icon-moon');
                    if (theme === 'dark') { sunIcon.classList.add('hidden'); moonIcon.classList.remove('hidden'); }
                    else { sunIcon.classList.remove('hidden'); moonIcon.classList.add('hidden'); }
                });

                textEditor.addEventListener('blur', finishTextEdit);
                textEditor.addEventListener('keydown', (e) => {
                    e.stopPropagation();
                    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); textEditor.blur(); }
                });
            }

            // --- MOUSE HANDLERS ---
            function onMouseDown(e) { handleMouseDown(e); }
            function onMouseMove(e) { handleMouseMove(e); }
            function onMouseUp(e) { handleMouseUp(e); }
            function onDoubleClick(e) { handleDoubleClick(e); }

            function handleMouseDown(e) {
                const mousePos = getEventPos(e);

                draggedWaypointInfo = getWaypointAt(mousePos);
                if (draggedWaypointInfo) { isDragging = false; return; }

                isReconnecting = getConnectorEndAt(mousePos);
                if (isReconnecting) { lastMousePos = mousePos; return; }

                if (selectedItems.length === 1) {
                    const shape = selectedItems[0];
                    if (getRotationHandleAt(mousePos, shape)) { isRotating = true; return; }
                    const connectionPoint = getConnectionPointAt(mousePos, shape);
                    if (connectionPoint) {
                        isConnecting = true;
                        currentConnector = { from: { shapeId: shape.id, point: connectionPoint }, to: { x: mousePos.x, y: mousePos.y } };
                        return;
                    }
                    resizeHandle = getResizeHandleAt(mousePos, shape);
                    if (resizeHandle) {
                        isResizing = true;
                        resizeAspectRatio = shape.width / shape.height;
                        // Capture initial state for robust resizing
                        startShapeState = {
                            x: shape.x, y: shape.y, w: shape.width, h: shape.height, rotation: shape.rotation || 0,
                            centerX: shape.x + shape.width / 2, centerY: shape.y + shape.height / 2
                        };
                        startMousePos = mousePos; // Capture start mouse pos
                        return;
                    }
                }

                const clickedConnector = getConnectorAt(mousePos);
                if (clickedConnector) {
                    selectedItems = []; selectedConnectors = [clickedConnector]; updatePropertiesPanel(); draw(); return;
                }

                const clickedShape = getShapeAt(mousePos);
                if (clickedShape) {
                    selectedConnectors = [];
                    if (!selectedItems.includes(clickedShape)) { selectedItems = [clickedShape]; }
                    isDragging = true;
                    lastMousePos = mousePos;
                } else {
                    selectedItems = []; selectedConnectors = [];
                    isSelecting = true;
                    selectionBox.x = mousePos.x; selectionBox.y = mousePos.y;
                    selectionBox.width = 0; selectionBox.height = 0;
                }
                updatePropertiesPanel();
                draw();
            }

            function handleMouseMove(e) {
                const mousePos = getEventPos(e);

                if (isRotating) {
                    const shape = selectedItems[0];
                    const centerX = shape.x + shape.width / 2;
                    const centerY = shape.y + shape.height / 2;
                    const angle = Math.atan2(mousePos.y - centerY, mousePos.x - centerX);
                    shape.rotation = angle + Math.PI / 2;
                    draw();
                    return;
                }

                if (isReconnecting) { lastMousePos = mousePos; draw(); return; }
                if (draggedWaypointInfo) { draggedWaypointInfo.connector.waypoints[draggedWaypointInfo.waypointIndex] = mousePos; draw(); return; }

                if (isPanning && !isMultiTouching) { // Mouse panning
                    cameraOffset.x += e.clientX - panStart.x;
                    cameraOffset.y += e.clientY - panStart.y;
                    panStart = { x: e.clientX, y: e.clientY };
                    draw(); return;
                }

                if (isResizing) {
                    const shape = selectedItems[0];
                    const dx = mousePos.x - startMousePos.x;
                    const dy = mousePos.y - startMousePos.y;

                    const sin = Math.sin(-(shape.rotation || 0));
                    const cos = Math.cos(-(shape.rotation || 0));
                    const localDx = dx * cos - dy * sin;
                    const localDy = dx * sin + dy * cos;

                    let newW = startShapeState.w;
                    let newH = startShapeState.h;
                    let newX = startShapeState.x;
                    let newY = startShapeState.y;

                    if (resizeHandle === 'bottomRight') {
                        // Anchor top-left
                        newW = startShapeState.w + localDx;
                        newH = startShapeState.h + localDy;
                        newX = startShapeState.x;
                        newY = startShapeState.y;
                    } else if (resizeHandle === 'bottomLeft') {
                        // Anchor top-right
                        newW = startShapeState.w - localDx;
                        newH = startShapeState.h + localDy;
                        newX = (startShapeState.x + startShapeState.w) - newW;
                        newY = startShapeState.y;
                    } else if (resizeHandle === 'topRight') {
                        // Anchor top-left
                        newW = startShapeState.w + localDx;
                        newH = startShapeState.h - localDy;
                        newX = startShapeState.x;
                        newY = (startShapeState.y + startShapeState.h) - newH;
                    } else if (resizeHandle === 'topLeft') {
                        // Anchor top-right
                        newW = startShapeState.w - localDx;
                        newH = startShapeState.h - localDy;
                        newX = (startShapeState.x + startShapeState.w) - newW;
                        newY = (startShapeState.y + startShapeState.h) - newH;
                    } else {
                        if (resizeHandle.includes('right')) newW = startShapeState.w + localDx;
                        if (resizeHandle.includes('left')) {
                            newW = startShapeState.w - localDx;
                            newX = startShapeState.x + localDx;
                        }
                        if (resizeHandle.includes('bottom')) newH = startShapeState.h + localDy;
                        if (resizeHandle.includes('top')) {
                            newH = startShapeState.h - localDy;
                            newY = startShapeState.y + localDy;
                        }
                    }

                    if (['topLeft', 'topRight', 'bottomLeft', 'bottomRight'].includes(resizeHandle)) {
                        const r = resizeAspectRatio;
                        const refinedH = (newW * r + newH) / (r * r + 1);
                        newW = refinedH * r;
                        newH = refinedH;
                        
                        // Recalculate position after proportional resize
                        if (resizeHandle === 'bottomRight') {
                            newX = startShapeState.x;
                            newY = startShapeState.y;
                        } else if (resizeHandle === 'bottomLeft') {
                            newX = (startShapeState.x + startShapeState.w) - newW;
                            newY = startShapeState.y;
                        } else if (resizeHandle === 'topRight') {
                            newX = startShapeState.x;
                            newY = (startShapeState.y + startShapeState.h) - newH;
                        } else if (resizeHandle === 'topLeft') {
                            newX = (startShapeState.x + startShapeState.w) - newW;
                            newY = (startShapeState.y + startShapeState.h) - newH;
                        }
                    }

                    if (newW < 20) newW = 20;
                    if (newH < 20) newH = 20;

                    shape.width = newW;
                    shape.height = newH;
                    shape.x = newX;
                    shape.y = newY;

                    if (snapToGrid) snapShape(shape);
                    draw();
                } else if (isDragging) {
                    const dx = mousePos.x - lastMousePos.x;
                    const dy = mousePos.y - lastMousePos.y;
                    selectedItems.forEach(shape => { shape.x += dx; shape.y += dy; updateChildrenPositions(shape, dx, dy); });
                    lastMousePos = mousePos;
                    draw();
                } else if (isConnecting) {
                    currentConnector.to = { x: mousePos.x, y: mousePos.y };
                    draw();
                    ctx.save(); ctx.translate(cameraOffset.x, cameraOffset.y);
                    const startShape = shapes.find(s => s.id === currentConnector.from.shapeId);
                    const startPoint = getAttachPoint(startShape, currentConnector.from.point);
                    ctx.beginPath(); ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.strokeStyle = '#28a745'; ctx.lineWidth = 2 / cameraZoom; ctx.setLineDash([5 / cameraZoom, 5 / cameraZoom]); ctx.stroke();
                    ctx.restore();
                } else if (isSelecting) {
                    selectionBox.width = mousePos.x - selectionBox.x;
                    selectionBox.height = mousePos.y - selectionBox.y;
                    draw();
                } else {
                    const prevHovered = hoveredConnector;
                    hoveredConnector = getConnectorAt(mousePos);
                    if (prevHovered !== hoveredConnector) draw();
                    if (selectedItems.length === 1) {
                        const shape = selectedItems[0];
                        if (getRotationHandleAt(mousePos, shape)) { canvas.style.cursor = 'crosshair'; return; }
                        const handle = getResizeHandleAt(mousePos, shape);
                        if (handle) { canvas.style.cursor = getResizeCursor(handle, shape.rotation || 0); return; }
                        if (getConnectionPointAt(mousePos, shape)) { canvas.style.cursor = 'crosshair'; return; }
                    }
                    canvas.style.cursor = hoveredConnector ? 'pointer' : (getShapeAt(mousePos) ? 'move' : 'default');
                }
            }

            function handleMouseUp(e) {
                const mousePos = getEventPos(e);

                if (isReconnecting) {
                    const endShape = getShapeAt(mousePos);
                    if (endShape) {
                        const isConnectingFrom = isReconnecting.end === 'from';
                        const staticEndShapeId = isConnectingFrom ? isReconnecting.connector.to.shapeId : isReconnecting.connector.from.shapeId;

                        if (endShape.id !== staticEndShapeId) {
                            let endPoint = null;
                            const points = getConnectionPoints(endShape);
                            let minDist = Infinity;
                            for (const pointName in points) {
                                const pointPos = getAttachPoint(endShape, pointName); // Get rotated point
                                const dist = Math.hypot(mousePos.x - pointPos.x, mousePos.y - pointPos.y);
                                if (dist < minDist) { minDist = dist; endPoint = pointName; }
                            }
                            if (endPoint) {
                                if (isConnectingFrom) { isReconnecting.connector.from = { shapeId: endShape.id, point: endPoint }; }
                                else { isReconnecting.connector.to = { shapeId: endShape.id, point: endPoint }; }
                            }
                        }
                    }
                    isReconnecting = null;
                } else if (isConnecting) {
                    const endShape = getShapeAt(mousePos);
                    let endPoint = null;
                    if (endShape && endShape.id !== currentConnector.from.shapeId) {
                        const points = getConnectionPoints(endShape);
                        let minDist = Infinity;
                        for (const pointName in points) {
                            const pointPos = getAttachPoint(endShape, pointName); // Get rotated point
                            const dist = Math.hypot(mousePos.x - pointPos.x, mousePos.y - pointPos.y);
                            if (dist < minDist) { minDist = dist; endPoint = pointName; }
                        }
                    }
                    if (endShape && endPoint) {
                        connectors.push({
                            id: Date.now(),
                            from: currentConnector.from,
                            to: { shapeId: endShape.id, point: endPoint },
                            waypoints: [],
                            color: '#ddd',
                            thickness: 2,
                            lineStyle: 'solid',
                            lineType: 'line'
                        });
                    }
                } else if (isSelecting) {
                    const box = getNormalizedSelectionBox();
                    selectedItems = shapes.filter(shape => shape.x < box.x + box.width && shape.x + shape.width > box.x && shape.y < box.y + box.height && shape.y + shape.height > box.y);
                    updatePropertiesPanel();
                }

                if (isDragging && snapToGrid) { selectedItems.forEach(snapShape); }

                draggedWaypointInfo = null;
                isDragging = false;
                isResizing = false;
                isConnecting = false;
                isSelecting = false;
                isRotating = false;
                currentConnector = null;
                selectionBox = { x: 0, y: 0, width: 0, height: 0 };
                draw();
            }

            // ... (Touch Handlers remain same)
            function onTouchStart(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    if (tapLength < 300 && tapLength > 0) { handleDoubleClick(e.touches[0]); }
                    lastTap = currentTime; handleMouseDown(e.touches[0]);
                } else if (e.touches.length === 2) {
                    isMultiTouching = true; isPanning = true; lastTouchDistance = getTouchDistance(e); panStart = getMidpoint(e);
                }
            }
            function onTouchMove(e) {
                e.preventDefault();
                if (e.touches.length === 1 && !isMultiTouching) { handleMouseMove(e.touches[0]); }
                else if (e.touches.length === 2) {
                    const midpoint = getMidpoint(e);
                    cameraOffset.x += midpoint.x - panStart.x; cameraOffset.y += midpoint.y - panStart.y; panStart = midpoint;
                    const newDist = getTouchDistance(e); const zoomFactor = newDist / lastTouchDistance;
                    const worldX = (midpoint.x - cameraOffset.x) / cameraZoom; const worldY = (midpoint.y - cameraOffset.y) / cameraZoom;
                    const newZoom = cameraZoom * zoomFactor; cameraZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
                    cameraOffset.x = midpoint.x - worldX * cameraZoom; cameraOffset.y = midpoint.y - worldY * cameraZoom;
                    lastTouchDistance = newDist; draw();
                }
            }
            function onTouchEnd(e) {
                e.preventDefault();
                if (e.touches.length === 0) { if (!isMultiTouching) handleMouseUp(e.changedTouches[0]); isMultiTouching = false; isPanning = false; lastTouchDistance = null; }
            }

            function handleDoubleClick(e) {
                const mousePos = getEventPos(e);

                const waypointHit = getWaypointAt(mousePos);
                if (waypointHit) {
                    waypointHit.connector.waypoints.splice(waypointHit.waypointIndex, 1);
                    draw(); return;
                }

                const shape = getShapeAt(mousePos);
                if (shape) { startTextEdit(shape); }
                else {
                    const hit = getConnectorSegmentAt(mousePos);
                    if (hit) {
                        if (!hit.connector.waypoints) { hit.connector.waypoints = []; }
                        hit.connector.waypoints.splice(hit.segmentIndex - 1, 0, mousePos);
                        selectedConnectors = [hit.connector]; selectedItems = []; updatePropertiesPanel(); draw();
                    }
                }
            }

            // ... (Wheel, Key handlers same) ...
            function onWheel(e) {
                e.preventDefault(); const rect = canvas.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
                const worldX = (mouseX - cameraOffset.x) / cameraZoom; const worldY = (mouseY - cameraOffset.y) / cameraZoom;
                const delta = e.deltaY * SCROLL_SENSITIVITY; const newZoom = cameraZoom * (1 - delta); cameraZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
                cameraOffset.x = mouseX - worldX * cameraZoom; cameraOffset.y = mouseY - worldY * cameraZoom; draw();
            }
            function onKeyDown(e) {
                const activeEl = document.activeElement; if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (e.key === ' ' && !isPanning) { isPanning = true; panStart = { x: e.clientX, y: e.clientY }; canvas.style.cursor = 'grabbing'; e.preventDefault(); }
                if ((e.key === 'Delete' || e.key === 'Backspace') && (selectedItems.length > 0 || selectedConnectors.length > 0)) { e.preventDefault(); deleteSelected(); }
            }
            function onKeyUp(e) { if (e.key === ' ') { isPanning = false; canvas.style.cursor = 'default'; } }
            function onDrop(e) { e.preventDefault(); const type = e.dataTransfer.getData('text/plain'); const mousePos = getEventPos(e); addShape(type, mousePos.x, mousePos.y); draw(); }

            // ... (Core Logic same, addShape, deleteSelected, textEdit, z-index...) ...
            function addShape(type, x, y) {
                const newShape = { id: Date.now(), type: type, x: x - 75, y: y - 40, width: 150, height: 80, text: 'New Shape', textColor: '#ffffff', fontSize: 14, fillColor: '#4a5568', borderColor: '#a0aec0', borderWidth: 2, fill: true, border: true, children: [], parentId: null, borderRadius: 4, opacity: 1, rotation: 0 };
                if (type === 'text') { newShape.fill = false; newShape.border = false; newShape.text = 'Enter text...'; }
                if (type === 'pie') { newShape.angle = 90; }
                if (type === 'checkmark') { newShape.fill = false; newShape.width = 50; newShape.height = 50; newShape.text = ''; }
                if (type === 'image') { newShape.text = ''; newShape.imageSrc = null; newShape.imageFit = 'fill'; }
                const parentShape = getShapeAt({ x, y }); if (parentShape) { newShape.parentId = parentShape.id; parentShape.children.push(newShape.id); }
                shapes.push(newShape); selectedItems = [newShape]; selectedConnectors = []; updatePropertiesPanel();
            }
            function deleteSelected() {
                if (selectedItems.length > 0) {
                    const idsToDelete = new Set(selectedItems.flatMap(s => s.type === 'group' ? [s.id, ...s.children] : [s.id]));
                    shapes = shapes.filter(s => !idsToDelete.has(s.id)); connectors = connectors.filter(c => !idsToDelete.has(c.from.shapeId) && !idsToDelete.has(c.to.shapeId));
                } else if (selectedConnectors.length > 0) {
                    const idsToDelete = new Set(selectedConnectors.map(c => c.id)); connectors = connectors.filter(c => !idsToDelete.has(c.id));
                }
                selectedItems = []; selectedConnectors = []; updatePropertiesPanel(); draw();
            }
            function startTextEdit(shape) {
                textEditor.style.display = 'block'; textEditor.value = shape.text;
                const screenX = shape.x * cameraZoom + cameraOffset.x; const screenY = shape.y * cameraZoom + cameraOffset.y;
                const screenWidth = shape.width * cameraZoom; const screenHeight = shape.height * cameraZoom;
                textEditor.style.left = `${screenX}px`; textEditor.style.top = `${screenY}px`; textEditor.style.width = `${screenWidth}px`; textEditor.style.height = `${screenHeight}px`;
                textEditor.style.fontSize = `${shape.fontSize * cameraZoom}px`; textEditor.style.textAlign = 'center'; textEditor.style.fontFamily = 'Inter'; textEditor.style.transform = `rotate(${shape.rotation || 0}rad)`;
                textEditor.focus(); textEditor.select();
            }
            function finishTextEdit() { if (selectedItems.length === 1) { selectedItems[0].text = textEditor.value; } textEditor.style.display = 'none'; textEditor.value = ''; textEditor.style.transform = 'rotate(0rad)'; draw(); updatePropertiesPanel(); }
            function bringForward(shape) { const index = shapes.findIndex(s => s.id === shape.id); if (index > -1 && index < shapes.length - 1) { [shapes[index], shapes[index + 1]] = [shapes[index + 1], shapes[index]]; draw(); } }
            function sendBackward(shape) { const index = shapes.findIndex(s => s.id === shape.id); if (index > 0) { [shapes[index], shapes[index - 1]] = [shapes[index - 1], shapes[index]]; draw(); } }
            function bringToFront(shape) { const index = shapes.findIndex(s => s.id === shape.id); if (index > -1 && index < shapes.length - 1) { shapes.splice(index, 1); shapes.push(shape); draw(); } }
            function sendToBack(shape) { const index = shapes.findIndex(s => s.id === shape.id); if (index > 0) { shapes.splice(index, 1); shapes.unshift(shape); draw(); } }
            function groupSelection() {
                if (selectedItems.length <= 1) return;
                let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
                selectedItems.forEach(s => { minX = Math.min(minX, s.x); minY = Math.min(minY, s.y); maxX = Math.max(maxX, s.x + s.width); maxY = Math.max(maxY, s.y + s.height); });
                const padding = 20;
                const groupShape = { id: Date.now(), type: 'group', x: minX - padding, y: minY - padding, width: (maxX - minX) + padding * 2, height: (maxY - minY) + padding * 2, text: '', borderColor: '#3498db', borderWidth: 2, fill: false, border: true, children: selectedItems.map(s => s.id), parentId: null, rotation: 0 };
                selectedItems.forEach(s => s.parentId = groupShape.id); shapes.push(groupShape); selectedItems = [groupShape]; updatePropertiesPanel(); draw();
            }
            function ungroupSelection() {
                if (selectedItems.length !== 1 || selectedItems[0].type !== 'group') return;
                const group = selectedItems[0];
                group.children.forEach(childId => { const child = shapes.find(s => s.id === childId); if (child) child.parentId = null; });
                shapes = shapes.filter(s => s.id !== group.id); selectedItems = []; updatePropertiesPanel(); draw();
            }

            // ... (Utility functions same, except rotatePoint used more) ...
            function getEventPos(evt) { const rect = canvas.getBoundingClientRect(); const clientX = evt.clientX ?? evt.touches[0].clientX; const clientY = evt.clientY ?? evt.touches[0].clientY; return { x: (clientX - rect.left - cameraOffset.x) / cameraZoom, y: (clientY - rect.top - cameraOffset.y) / cameraZoom }; }
            function getShapeAt(pos) {
                for (let i = shapes.length - 1; i >= 0; i--) {
                    const shape = shapes[i];
                    const center = { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 };
                    const unrotatedPos = rotatePoint(pos, center, -(shape.rotation || 0));
                    if (unrotatedPos.x >= shape.x && unrotatedPos.x <= shape.x + shape.width && unrotatedPos.y >= shape.y && unrotatedPos.y <= shape.y + shape.height) { return shape; }
                } return null;
            }
            function getConnectorPath(connector) {
                const startShape = shapes.find(s => s.id === connector.from.shapeId); const endShape = shapes.find(s => s.id === connector.to.shapeId); if (!startShape || !endShape) return [];
                const startPoint = getAttachPoint(startShape, connector.from.point); const endPoint = getAttachPoint(endShape, connector.to.point);
                return [startPoint, ...(connector.waypoints || []), endPoint];
            }
            function getConnectorSegmentAt(pos) {
                const hitRadius = 5 / cameraZoom;
                for (const connector of connectors) {
                    const pathPoints = getConnectorPath(connector); if (pathPoints.length < 2) continue;
                    const lineType = connector.lineType || 'line'; const hasWaypoints = connector.waypoints && connector.waypoints.length > 0;
                    let effectivePathPoints = pathPoints;
                    if (lineType === 'curve' && hasWaypoints) {
                        const approxPoints = []; const steps = 20; let p0 = pathPoints[0]; approxPoints.push(p0);
                        for (let i = 1; i < pathPoints.length - 1; i++) {
                            const p1 = pathPoints[i]; const p2 = (i < pathPoints.length - 2) ? { x: (p1.x + pathPoints[i + 1].x) / 2, y: (p1.y + pathPoints[i + 1].y) / 2 } : pathPoints[i + 1];
                            for (let j = 1; j <= steps; j++) { const t = j / steps; const mt = 1 - t; approxPoints.push({ x: mt * mt * p0.x + 2 * mt * t * p1.x + t * t * p2.x, y: mt * mt * p0.y + 2 * mt * t * p1.y + t * t * p2.y }); } p0 = p2;
                        } effectivePathPoints = approxPoints;
                    }
                    for (let i = 0; i < effectivePathPoints.length - 1; i++) {
                        const p1 = effectivePathPoints[i]; const p2 = effectivePathPoints[i + 1];
                        if (isPointOnLineSegment(pos, p1, p2, hitRadius)) { let closestOrigSegment = 0; let minDistSq = Infinity; for (let j = 0; j < pathPoints.length - 1; j++) { const distSq = distToSegmentSquared(pos, pathPoints[j], pathPoints[j + 1]); if (distSq < minDistSq) { minDistSq = distSq; closestOrigSegment = j + 1; } } return { connector, segmentIndex: closestOrigSegment }; }
                    }
                } return null;
            }
            function getConnectorAt(pos) { const hitInfo = getConnectorSegmentAt(pos); return hitInfo ? hitInfo.connector : null; }
            function getConnectorEndAt(pos) {
                if (selectedConnectors.length !== 1) return null; const connector = selectedConnectors[0]; const pathPoints = getConnectorPath(connector); if (pathPoints.length < 2) return null;
                const startPoint = pathPoints[0]; const endPoint = pathPoints[pathPoints.length - 1]; const hitRadius = 10 / cameraZoom;
                const distToStart = Math.hypot(pos.x - startPoint.x, pos.y - startPoint.y); const distToEnd = Math.hypot(pos.x - endPoint.x, pos.y - endPoint.y);
                if (distToEnd < hitRadius) { return { connector, end: 'to' }; } if (distToStart < hitRadius) { return { connector, end: 'from' }; } return null;
            }
            function getWaypointAt(pos) {
                const hitRadius = 8 / cameraZoom; if (selectedConnectors.length === 1) { const connector = selectedConnectors[0]; if (!connector.waypoints) return null; for (let i = 0; i < connector.waypoints.length; i++) { const wp = connector.waypoints[i]; const distSq = (pos.x - wp.x) * (pos.x - wp.x) + (pos.y - wp.y) * (pos.y - wp.y); if (distSq < (hitRadius * hitRadius)) { return { connector, waypointIndex: i }; } } } return null;
            }
            function getRotationHandle(shape) { return { x: shape.x + shape.width / 2, y: shape.y - 30 / cameraZoom }; }
            function getResizeHandles(shape) {
                return {
                    topLeft: { x: shape.x, y: shape.y }, topRight: { x: shape.x + shape.width, y: shape.y },
                    bottomLeft: { x: shape.x, y: shape.y + shape.height }, bottomRight: { x: shape.x + shape.width, y: shape.y + shape.height },
                    top: { x: shape.x + shape.width / 2, y: shape.y }, bottom: { x: shape.x + shape.width / 2, y: shape.y + shape.height },
                    left: { x: shape.x, y: shape.y + shape.height / 2 }, right: { x: shape.x + shape.width, y: shape.y + shape.height / 2 },
                };
            }
            function getConnectionPoints(shape) {
                const offset = 15 / cameraZoom;
                return {
                    top: { x: shape.x + shape.width / 2, y: shape.y - offset }, bottom: { x: shape.x + shape.width / 2, y: shape.y + shape.height + offset },
                    left: { x: shape.x - offset, y: shape.y + shape.height / 2 }, right: { x: shape.x + shape.width + offset, y: shape.y + shape.height / 2 },
                };
            }
            function getRotationHandleAt(pos, shape) { const center = { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }; const handlePos = rotatePoint(getRotationHandle(shape), center, shape.rotation || 0); const hitRadius = 10 / cameraZoom; return Math.hypot(pos.x - handlePos.x, pos.y - handlePos.y) < hitRadius; }
            function getResizeHandleAt(pos, shape) { const handles = getResizeHandles(shape); const center = { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }; const hitRadius = 14 / cameraZoom; for (const handle in handles) { const rotatedHandle = rotatePoint(handles[handle], center, shape.rotation || 0); if (Math.hypot(pos.x - rotatedHandle.x, pos.y - rotatedHandle.y) < hitRadius / 2) return handle; } return null; }
            function getConnectionPointAt(pos, shape) { const points = getConnectionPoints(shape); const center = { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }; const hitRadius = 10 / cameraZoom; for (const point in points) { const rotatedPoint = rotatePoint(points[point], center, shape.rotation || 0); if (Math.hypot(pos.x - rotatedPoint.x, pos.y - rotatedPoint.y) < hitRadius / 2) return point; } return null; }
            function getAttachPoint(shape, pointName) { const unrotatedPoints = getConnectionPoints(shape); const center = { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 }; const unrotatedPoint = unrotatedPoints[pointName] || center; return rotatePoint(unrotatedPoint, center, shape.rotation || 0); }
            function rotatePoint(point, center, angle) { const dx = point.x - center.x; const dy = point.y - center.y; const cos = Math.cos(angle); const sin = Math.sin(angle); return { x: center.x + dx * cos - dy * sin, y: center.y + dx * sin + dy * cos }; }
            function getResizeCursor(handle, rotation = 0) {
                let angle = 0;
                switch (handle) { case 'right': angle = 0; break; case 'bottomRight': angle = 45; break; case 'bottom': angle = 90; break; case 'bottomLeft': angle = 135; break; case 'left': angle = 180; break; case 'topLeft': angle = 225; break; case 'top': angle = 270; break; case 'topRight': angle = 315; break; }
                angle += (rotation * 180 / Math.PI); angle = (angle % 360 + 360) % 360;
                if (angle >= 337.5 || angle < 22.5) return 'ew-resize'; if (angle >= 22.5 && angle < 67.5) return 'nwse-resize'; if (angle >= 67.5 && angle < 112.5) return 'ns-resize'; if (angle >= 112.5 && angle < 157.5) return 'nesw-resize'; if (angle >= 157.5 && angle < 202.5) return 'ew-resize'; if (angle >= 202.5 && angle < 247.5) return 'nwse-resize'; if (angle >= 247.5 && angle < 292.5) return 'ns-resize'; if (angle >= 292.5 && angle < 337.5) return 'nesw-resize'; return 'default';
            }
            function snapShape(shape) { shape.x = Math.round(shape.x / GRID_SIZE) * GRID_SIZE; shape.y = Math.round(shape.y / GRID_SIZE) * GRID_SIZE; shape.width = Math.round(shape.width / GRID_SIZE) * GRID_SIZE; shape.height = Math.round(shape.height / GRID_SIZE) * GRID_SIZE; }
            function isPointOnLineSegment(p, a, b, radius) { const dx = b.x - a.x, dy = b.y - a.y; const lenSq = dx * dx + dy * dy; if (lenSq === 0) { return Math.hypot(p.x - a.x, p.y - a.y) < radius; } let t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / lenSq; t = Math.max(0, Math.min(1, t)); const closestX = a.x + t * dx; const closestY = a.y + t * dy; const distSq = (p.x - closestX) * (p.x - closestX) + (p.y - closestY) * (p.y - closestY); return distSq < radius * radius; }
            function distToSegmentSquared(p, a, b) { const dx = b.x - a.x, dy = b.y - a.y; const lenSq = dx * dx + dy * dy; if (lenSq === 0) { return Math.hypot(p.x - a.x, p.y - a.y) ** 2; } let t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / lenSq; t = Math.max(0, Math.min(1, t)); const closestX = a.x + t * dx; const closestY = a.y + t * dy; return (p.x - closestX) * (p.x - closestX) + (p.y - closestY) * (p.y - closestY); }
            function updateChildrenPositions(parentShape, dx, dy) { if (parentShape.type !== 'group' || !parentShape.children) return; parentShape.children.forEach(childId => { const child = shapes.find(s => s.id === childId); if (child) { child.x += dx; child.y += dy; updateChildrenPositions(child, dx, dy); } }); }
            function getNormalizedSelectionBox() { const x = selectionBox.width < 0 ? selectionBox.x + selectionBox.width : selectionBox.x; const y = selectionBox.height < 0 ? selectionBox.y + selectionBox.height : selectionBox.y; const width = Math.abs(selectionBox.width); const height = Math.abs(selectionBox.height); return { x, y, width, height }; }
            function getTouchDistance(e) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; return Math.hypot(dx, dy); }
            function getMidpoint(e) { return { x: (e.touches[0].clientX + e.touches[1].clientX) / 2, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 }; }

            // --- PROPERTIES PANEL (same) ---
            function updatePropertiesPanel() {
                // ... (Same logic as previously generated, truncated for brevity as only logic changes were requested)
                if (selectedItems.length === 1) {
                    const shape = selectedItems[0];
                    let content = `
                        <div class="grid grid-cols-2 gap-2">
                             <button id="prop-bring-forward" class="p-2 w-full bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-100 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 text-sm">Bring Forward</button>
                             <button id="prop-bring-front" class="p-2 w-full bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-100 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 text-sm">Bring to Front</button>
                             <button id="prop-send-backward" class="p-2 w-full bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-100 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 text-sm">Send Backward</button>
                             <button id="prop-send-back" class="p-2 w-full bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-100 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 text-sm">Send to Back</button>
                        </div>
                        <hr class="border-gray-300 dark:border-gray-600 my-2">`;

                    if (shape.type === 'image') {
                        content += `
                            <div class="space-y-2"><label class="block text-sm font-medium">Image Source</label><input type="file" id="prop-image-upload" accept="image/*" class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 dark:file:bg-gray-700 dark:file:text-gray-200"></div>
                            <div class="space-y-2"><label class="block text-sm font-medium">Image Fit</label><select id="prop-image-fit" class="w-full p-1 border rounded-md bg-white dark:bg-gray-700 dark:border-gray-600"><option value="fill" ${!shape.imageFit || shape.imageFit === 'fill' ? 'selected' : ''}>Fill</option><option value="aspectFit" ${shape.imageFit === 'aspectFit' ? 'selected' : ''}>Aspect Fit</option><option value="aspectFill" ${shape.imageFit === 'aspectFill' ? 'selected' : ''}>Aspect Fill</option><option value="center" ${shape.imageFit === 'center' ? 'selected' : ''}>Center</option></select></div>
                            <div class="space-y-2"><label class="block text-sm font-medium">Opacity (${Math.round((shape.opacity || 1) * 100)}%)</label><input type="range" id="prop-opacity" min="0" max="1" step="0.05" class="w-full" value="${shape.opacity || 1}"></div>
                        `;
                    } else {
                        content += `<div class="space-y-2"><label class="block text-sm font-medium">Text</label><textarea id="prop-text" class="w-full p-1 border rounded-md bg-white dark:bg-gray-700 dark:border-gray-600">${shape.text}</textarea></div> <div class="space-y-2"><label class="block text-sm font-medium">Font Size</label><input type="number" id="prop-font-size" class="w-full p-1 border rounded-md bg-white dark:bg-gray-700 dark:border-gray-600" value="${shape.fontSize}"></div> <div class="space-y-2"><label class="block text-sm font-medium">Text Color</label><input type="color" id="prop-text-color" class="w-full h-8 p-1 border rounded-md" value="${shape.textColor}"></div>`;
                    }

                    if (shape.type !== 'text' && shape.type !== 'image') {
                        content += `<div class="space-y-2"><label class="block text-sm font-medium">Fill Color</label><div class="flex items-center space-x-2"><input type="checkbox" id="prop-fill-toggle" ${shape.fill ? 'checked' : ''}><input type="color" id="prop-fill-color" class="w-full h-8 p-1 border rounded-md" value="${shape.fillColor}"></div></div> <div class="space-y-2"><label class="block text-sm font-medium">Border Color</label><div class="flex items-center space-x-2"><input type="checkbox" id="prop-border-toggle" ${shape.border ? 'checked' : ''}><input type="color" id="prop-border-color" class="w-full h-8 p-1 border rounded-md" value="${shape.borderColor}"></div></div> <div class="space-y-2"><label class="block text-sm font-medium">Border Width</label><input type="number" id="prop-border-width" class="w-full p-1 border rounded-md bg-white dark:bg-gray-700 dark:border-gray-600" value="${shape.borderWidth}"></div>`;
                        if (shape.type === 'rectangle') { content += `<div class="space-y-2"><label class="block text-sm font-medium">Roundness</label><input type="number" id="prop-border-radius" class="w-full p-1 border rounded-md bg-white dark:bg-gray-700 dark:border-gray-600" value="${shape.borderRadius || 0}" min="0"></div>`; }
                        content += `<div class="space-y-2"><label class="block text-sm font-medium">Opacity (${Math.round((shape.opacity || 1) * 100)}%)</label><input type="range" id="prop-opacity" min="0" max="1" step="0.05" class="w-full" value="${shape.opacity || 1}"></div>`;
                    }
                    if (shape.type === 'pie') { content += `<div class="space-y-2"><label class="block text-sm font-medium">Angle (${shape.angle})</label><input type="range" id="prop-angle" min="0" max="360" class="w-full" value="${shape.angle}"></div>`; }
                    propertiesContent.innerHTML = content;

                    document.getElementById('prop-bring-front').addEventListener('click', () => bringToFront(shape));
                    document.getElementById('prop-send-back').addEventListener('click', () => sendToBack(shape));
                    document.getElementById('prop-bring-forward').addEventListener('click', () => bringForward(shape));
                    document.getElementById('prop-send-backward').addEventListener('click', () => sendBackward(shape));

                    if (shape.type === 'image') {
                        const fileInput = document.getElementById('prop-image-upload');
                        fileInput.addEventListener('change', (e) => {
                            const file = e.target.files[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (event) => { shape.imageSrc = event.target.result; shape.imageElem = null; draw(); };
                                reader.readAsDataURL(file);
                            }
                        });
                        const fitInput = document.getElementById('prop-image-fit');
                        fitInput.addEventListener('change', (e) => { shape.imageFit = e.target.value; draw(); });
                        const opacityInput = document.getElementById('prop-opacity');
                        if (opacityInput) { opacityInput.addEventListener('input', (e) => { shape.opacity = parseFloat(e.target.value); e.target.previousElementSibling.innerText = `Opacity (${Math.round(shape.opacity * 100)}%)`; draw(); }); }
                    } else {
                        document.getElementById('prop-text').addEventListener('input', (e) => { shape.text = e.target.value; draw(); });
                        document.getElementById('prop-font-size').addEventListener('input', (e) => { shape.fontSize = parseInt(e.target.value); draw(); });
                        document.getElementById('prop-text-color').addEventListener('input', (e) => { shape.textColor = e.target.value; draw(); });
                    }

                    if (shape.type !== 'text' && shape.type !== 'image') {
                        document.getElementById('prop-fill-color').addEventListener('input', (e) => { shape.fillColor = e.target.value; draw(); });
                        document.getElementById('prop-fill-toggle').addEventListener('change', (e) => { shape.fill = e.target.checked; draw(); });
                        document.getElementById('prop-border-color').addEventListener('input', (e) => { shape.borderColor = e.target.value; draw(); });
                        document.getElementById('prop-border-toggle').addEventListener('change', (e) => { shape.border = e.target.checked; draw(); });
                        document.getElementById('prop-border-width').addEventListener('input', (e) => { shape.borderWidth = parseInt(e.target.value); draw(); });
                        const opacityInput = document.getElementById('prop-opacity');
                        if (opacityInput) { opacityInput.addEventListener('input', (e) => { shape.opacity = parseFloat(e.target.value); e.target.previousElementSibling.innerText = `Opacity (${Math.round(shape.opacity * 100)}%)`; draw(); }); }
                        if (shape.type === 'rectangle') { const radiusInput = document.getElementById('prop-border-radius'); if (radiusInput) { radiusInput.addEventListener('input', (e) => { shape.borderRadius = parseInt(e.target.value) || 0; draw(); }); } }
                    }
                    if (shape.type === 'pie') { document.getElementById('prop-angle').addEventListener('input', (e) => { shape.angle = parseInt(e.target.value); e.target.previousElementSibling.innerText = `Angle (${shape.angle})`; draw(); }); }
                } else if (selectedConnectors.length === 1) {
                    const connector = selectedConnectors[0];
                    let content = `
                        <div class="space-y-2"><label class="block text-sm font-medium">Connector Color</label><input type="color" id="prop-connector-color" class="w-full h-8 p-1 border rounded-md" value="${connector.color || '#dddddd'}"></div>
                        <div class="space-y-2"><label class="block text-sm font-medium">Thickness</label><input type="number" id="prop-connector-thickness" class="w-full p-1 border rounded-md bg-white dark:bg-gray-700 dark:border-gray-600" value="${connector.thickness || 2}" min="1"></div>
                        <div class="space-y-2"><label class="block text-sm font-medium">Line Style</label><select id="prop-connector-style" class="w-full p-1 border rounded-md bg-white dark:bg-gray-700 dark:border-gray-600"><option value="solid" ${!connector.lineStyle || connector.lineStyle === 'solid' ? 'selected' : ''}>Solid</option><option value="dashed" ${connector.lineStyle === 'dashed' ? 'selected' : ''}>Dashed</option><option value="dotted" ${connector.lineStyle === 'dotted' ? 'selected' : ''}>Dotted</option></select></div>
                         <div class="space-y-2"><label class="block text-sm font-medium">Line Type</label><select id="prop-connector-type" class="w-full p-1 border rounded-md bg-white dark:bg-gray-700 dark:border-gray-600"><option value="line" ${!connector.lineType || connector.lineType === 'line' ? 'selected' : ''}>Line</option><option value="curve" ${connector.lineType === 'curve' ? 'selected' : ''}>Curve</option></select></div>
                    `;
                    propertiesContent.innerHTML = content;
                    document.getElementById('prop-connector-color').addEventListener('input', (e) => { connector.color = e.target.value; draw(); });
                    document.getElementById('prop-connector-thickness').addEventListener('input', (e) => { connector.thickness = parseInt(e.target.value) || 1; draw(); });
                    document.getElementById('prop-connector-style').addEventListener('change', (e) => { connector.lineStyle = e.target.value; draw(); });
                    document.getElementById('prop-connector-type').addEventListener('change', (e) => { connector.lineType = e.target.value; draw(); });
                } else {
                    propertiesContent.innerHTML = `<p class="text-gray-600 dark:text-gray-400">${selectedItems.length > 1 ? selectedItems.length + ' items selected.' : 'Select an object.'}</p>`;
                }
            }

            // --- THEME & IO ---
            function exportJSON() {
                const data = { shapes, connectors, cameraOffset, cameraZoom };
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'flowchart.json'; a.click(); URL.revokeObjectURL(url);
            }
            function importJSON(e) {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => { try { const data = JSON.parse(event.target.result); shapes = data.shapes || []; shapes.forEach(s => { if (s.type === 'image') s.imageElem = null; }); connectors = data.connectors || []; cameraOffset = data.cameraOffset || { x: 0, y: 0 }; cameraZoom = data.cameraZoom || 1; selectedItems = []; selectedConnectors = []; updatePropertiesPanel(); draw(); } catch (error) { console.error("Error parsing JSON file:", error); } };
                reader.readAsText(file);
            }
            function exportPNG() {
                const originallySelectedItems = [...selectedItems]; const originallySelectedConnectors = [...selectedConnectors]; selectedItems = []; selectedConnectors = []; draw();
                const a = document.createElement('a'); a.href = canvas.toDataURL('image/png'); a.download = 'flowchart.png'; a.click();
                selectedItems = originallySelectedItems; selectedConnectors = originallySelectedConnectors; draw();
            }

            // --- RUN ---
            init();
        });
    </script>
</body>
</html>
